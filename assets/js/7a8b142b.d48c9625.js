"use strict";(globalThis.webpackChunkhomanoid_robotics_book=globalThis.webpackChunkhomanoid_robotics_book||[]).push([[5658],{8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var i=r(6540);const s={},l=i.createContext(s);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(l.Provider,{value:n},e.children)}},9067:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-1/chapter-2","title":"Chapter 2: Writing Nodes with rclpy","description":"Learning Outcomes","source":"@site/docs/module-1/chapter-2.md","sourceDirName":"module-1","slug":"/module-1/chapter-2","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-1/chapter-2","draft":false,"unlisted":false,"editUrl":"https://github.com/KashanKamboh/Physical-AI-Humanoid-Robotics-Book.git/edit/main/docs/module-1/chapter-2.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Introduction to ROS 2 Architecture","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-1/chapter-1"},"next":{"title":"Chapter 3: URDF for Humanoids","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-1/chapter-3"}}');var s=r(4848),l=r(8453);const t={sidebar_position:3},o="Chapter 2: Writing Nodes with rclpy",a={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites Checklist",id:"prerequisites-checklist",level:2},{value:"Required Software Installed",id:"required-software-installed",level:3},{value:"Required Module Completion",id:"required-module-completion",level:3},{value:"Files Needed",id:"files-needed",level:3},{value:"Core Concept Explanation",id:"core-concept-explanation",level:2},{value:"rclpy Client Library",id:"rclpy-client-library",level:3},{value:"Node Structure and Lifecycle",id:"node-structure-and-lifecycle",level:3},{value:"Quality of Service (QoS) Profiles",id:"quality-of-service-qos-profiles",level:3},{value:"Diagram or Pipeline",id:"diagram-or-pipeline",level:2},{value:"Runnable Code Example A",id:"runnable-code-example-a",level:2},{value:"Runnable Code Example B",id:"runnable-code-example-b",level:2},{value:"&quot;Try Yourself&quot; Mini Task",id:"try-yourself-mini-task",level:2},{value:"Verification Procedure",id:"verification-procedure",level:2},{value:"What appears in terminal?",id:"what-appears-in-terminal",level:3},{value:"What changes in simulation?",id:"what-changes-in-simulation",level:3},{value:"Checklist for Completion",id:"checklist-for-completion",level:2},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-2-writing-nodes-with-rclpy",children:"Chapter 2: Writing Nodes with rclpy"})}),"\n",(0,s.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,s.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create ROS 2 nodes using the rclpy client library"}),"\n",(0,s.jsx)(n.li,{children:"Implement publishers, subscribers, services, and actions"}),"\n",(0,s.jsx)(n.li,{children:"Use launch files to manage complex node configurations"}),"\n",(0,s.jsx)(n.li,{children:"Handle parameters and configuration in ROS 2 nodes"}),"\n",(0,s.jsx)(n.li,{children:"Debug and monitor node performance"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites-checklist",children:"Prerequisites Checklist"}),"\n",(0,s.jsx)(n.h3,{id:"required-software-installed",children:"Required Software Installed"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","ROS 2 Humble Hawksbill (or newer)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Python 3.8+ with pip"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Completed Chapter 1 content"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"required-module-completion",children:"Required Module Completion"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understanding of ROS 2 architecture concepts"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Basic Python programming knowledge"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Familiarity with object-oriented programming"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"files-needed",children:"Files Needed"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Completed publisher/subscriber example from Chapter 1"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Access to rclpy documentation"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"core-concept-explanation",children:"Core Concept Explanation"}),"\n",(0,s.jsx)(n.h3,{id:"rclpy-client-library",children:"rclpy Client Library"}),"\n",(0,s.jsx)(n.p,{children:"The rclpy package is the Python client library for ROS 2. It provides a Python API that allows you to create ROS 2 nodes, publish and subscribe to topics, provide and call services, and more. rclpy is built on top of the ROS Client Library (rcl) and the DDS implementation."}),"\n",(0,s.jsx)(n.h3,{id:"node-structure-and-lifecycle",children:"Node Structure and Lifecycle"}),"\n",(0,s.jsx)(n.p,{children:"A ROS 2 node in Python follows a standard structure:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Initialization"}),": Set up the node with a unique name"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Entity Creation"}),": Create publishers, subscribers, services, etc."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Execution"}),": Run the main logic, often in a loop or through callbacks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cleanup"}),": Properly shut down resources when done"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"quality-of-service-qos-profiles",children:"Quality of Service (QoS) Profiles"}),"\n",(0,s.jsx)(n.p,{children:"QoS profiles allow you to specify the behavior of your communication patterns. Key QoS settings include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reliability"}),": Whether messages are guaranteed to be delivered"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Durability"}),": Whether late-joining subscribers get old messages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"History"}),": How many messages to keep for late-joining subscribers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Depth"}),": How many messages to keep in the queue"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"diagram-or-pipeline",children:"Diagram or Pipeline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph TB\r\n    A[rclpy Node Structure] --\x3e B[Initialization]\r\n    A --\x3e C[Entity Creation]\r\n    A --\x3e D[Execution Loop]\r\n    A --\x3e E[Cleanup]\r\n\r\n    B --\x3e B1[rclpy.init()]\r\n    B --\x3e B2[Node Creation]\r\n\r\n    C --\x3e C1[Publishers]\r\n    C --\x3e C2[Subscribers]\r\n    C --\x3e C3[Services]\r\n    C --\x3e C4[Actions]\r\n\r\n    D --\x3e D1[Spin/Callbacks]\r\n    D --\x3e D2[Timer Callbacks]\r\n    D --\x3e D3[Service Callbacks]\r\n\r\n    E --\x3e E1[Destroy Entities]\r\n    E --\x3e E2[rclpy.shutdown()]\r\n\r\n    B1 --\x3e D\r\n    C1 --\x3e D\r\n    C2 --\x3e D\r\n    C3 --\x3e D\r\n    C4 --\x3e D\n"})}),"\n",(0,s.jsx)(n.h2,{id:"runnable-code-example-a",children:"Runnable Code Example A"}),"\n",(0,s.jsx)(n.p,{children:"Let's create a more complex node that demonstrates multiple communication patterns:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# complex_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom std_srvs.srv import SetBool\r\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\r\n\r\n\r\nclass ComplexNode(Node):\r\n\r\n    def __init__(self):\r\n        super().__init__('complex_node')\r\n\r\n        # Create a publisher with custom QoS profile\r\n        qos_profile = QoSProfile(\r\n            depth=10,\r\n            reliability=ReliabilityPolicy.RELIABLE,\r\n            durability=DurabilityPolicy.VOLATILE\r\n        )\r\n        self.publisher_ = self.create_publisher(String, 'chatter', qos_profile)\r\n\r\n        # Create a subscriber\r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            'input_topic',\r\n            self.listener_callback,\r\n            qos_profile\r\n        )\r\n\r\n        # Create a service server\r\n        self.srv = self.create_service(SetBool, 'toggle_service', self.toggle_callback)\r\n\r\n        # Create a timer\r\n        self.timer = self.create_timer(0.5, self.timer_callback)\r\n\r\n        # Internal state\r\n        self.is_active = True\r\n        self.counter = 0\r\n\r\n        self.get_logger().info('Complex node initialized')\r\n\r\n    def timer_callback(self):\r\n        if self.is_active:\r\n            msg = String()\r\n            msg.data = f'Complex message {self.counter}'\r\n            self.publisher_.publish(msg)\r\n            self.get_logger().info(f'Published: {msg.data}')\r\n            self.counter += 1\r\n\r\n    def listener_callback(self, msg):\r\n        self.get_logger().info(f'Received: {msg.data}')\r\n        # Echo the message back with modification\r\n        response_msg = String()\r\n        response_msg.data = f'Echo: {msg.data}'\r\n        self.publisher_.publish(response_msg)\r\n\r\n    def toggle_callback(self, request, response):\r\n        self.is_active = request.data\r\n        response.success = True\r\n        response.message = f'Node active status set to: {self.is_active}'\r\n        self.get_logger().info(f'Service called: {response.message}')\r\n        return response\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = ComplexNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"To run this code:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Save it as ",(0,s.jsx)(n.code,{children:"complex_node.py"})]}),"\n",(0,s.jsx)(n.li,{children:"Make sure your ROS 2 workspace is sourced"}),"\n",(0,s.jsxs)(n.li,{children:["Run: ",(0,s.jsx)(n.code,{children:"ros2 run <package_name> complex_node"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"runnable-code-example-b",children:"Runnable Code Example B"}),"\n",(0,s.jsx)(n.p,{children:"Now let's create a client node that interacts with our complex node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# client_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom std_srvs.srv import SetBool\r\nimport time\r\n\r\n\r\nclass ClientNode(Node):\r\n\r\n    def __init__(self):\r\n        super().__init__('client_node')\r\n\r\n        # Create publisher to send messages to complex node\r\n        self.publisher_ = self.create_publisher(String, 'input_topic', 10)\r\n\r\n        # Create client for the service\r\n        self.cli = self.create_client(SetBool, 'toggle_service')\r\n\r\n        # Wait for service to be available\r\n        while not self.cli.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info('Service not available, waiting again...')\r\n\r\n        self.req = SetBool.Request()\r\n\r\n        # Create timer to send periodic requests\r\n        self.timer = self.create_timer(2.0, self.timer_callback)\r\n        self.toggle_state = True\r\n\r\n    def timer_callback(self):\r\n        # Toggle the complex node's active state\r\n        self.req.data = self.toggle_state\r\n        self.future = self.cli.call_async(self.req)\r\n        self.future.add_done_callback(self.service_response_callback)\r\n\r\n        # Send a message to the input topic\r\n        msg = String()\r\n        msg.data = f'Client message at {time.time()}'\r\n        self.publisher_.publish(msg)\r\n        self.get_logger().info(f'Sent: {msg.data}')\r\n\r\n        # Alternate the toggle state\r\n        self.toggle_state = not self.toggle_state\r\n\r\n    def service_response_callback(self, future):\r\n        try:\r\n            response = future.result()\r\n            self.get_logger().info(f'Service response: {response.message}')\r\n        except Exception as e:\r\n            self.get_logger().error(f'Service call failed: {e}')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = ClientNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"To run this code:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Save it as ",(0,s.jsx)(n.code,{children:"client_node.py"})]}),"\n",(0,s.jsxs)(n.li,{children:["First run the complex node in one terminal: ",(0,s.jsx)(n.code,{children:"ros2 run <package_name> complex_node"})]}),"\n",(0,s.jsxs)(n.li,{children:["Then run the client node in another terminal: ",(0,s.jsx)(n.code,{children:"ros2 run <package_name> client_node"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"try-yourself-mini-task",children:'"Try Yourself" Mini Task'}),"\n",(0,s.jsxs)(n.p,{children:["Create a launch file that starts both the complex node and the client node simultaneously. The launch file should be named ",(0,s.jsx)(n.code,{children:"complex_system_launch.py"})," and should:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Launch the complex node with a custom parameter"}),"\n",(0,s.jsx)(n.li,{children:"Launch the client node after a 2-second delay"}),"\n",(0,s.jsx)(n.li,{children:"Include proper error handling"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Hint:"})," Use ",(0,s.jsx)(n.code,{children:"launch_ros.actions.Node"})," to define each node and ",(0,s.jsx)(n.code,{children:"launch.actions.TimerAction"})," for the delay."]}),"\n",(0,s.jsx)(n.h2,{id:"verification-procedure",children:"Verification Procedure"}),"\n",(0,s.jsx)(n.p,{children:"To verify that your rclpy nodes are working correctly:"}),"\n",(0,s.jsx)(n.h3,{id:"what-appears-in-terminal",children:"What appears in terminal?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'When running the complex node: You should see initialization messages and periodic "Published" messages when active'}),"\n",(0,s.jsx)(n.li,{children:'When running the client node: You should see "Sent" messages and service response logs'}),"\n",(0,s.jsx)(n.li,{children:"When running both together: You should see interaction between nodes, with messages being echoed and service calls being made"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"what-changes-in-simulation",children:"What changes in simulation?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In ",(0,s.jsx)(n.code,{children:"rqt_graph"}),", you should see both nodes connected with topic and service links"]}),"\n",(0,s.jsxs)(n.li,{children:["In ",(0,s.jsx)(n.code,{children:"rqt_console"}),", you should see detailed logging information"]}),"\n",(0,s.jsx)(n.li,{children:"System resource usage should show two active ROS 2 processes"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"checklist-for-completion",children:"Checklist for Completion"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Complex node created with multiple communication patterns"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Client node created to interact with the complex node"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Both nodes running and communicating successfully"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Launch file created for simultaneous execution (Try Yourself task)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Verification steps completed successfully"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","QoS profiles understood and applied"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"This chapter demonstrated how to create more complex ROS 2 nodes using rclpy, incorporating multiple communication patterns including publishers, subscribers, and services. You learned about QoS profiles and how to structure nodes with proper initialization, execution, and cleanup. The launch file exercise showed how to orchestrate multiple nodes for system-level operation."}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Open Source Robotics Foundation. (2023). ",(0,s.jsx)(n.em,{children:"ROS 2 Client Libraries (rcl) Design"}),". Retrieved from ",(0,s.jsx)(n.a,{href:"https://design.ros2.org/articles/overview.html",children:"https://design.ros2.org/articles/overview.html"})]}),"\n",(0,s.jsx)(n.li,{children:"Source 003: Technical paper on rclpy implementation and performance"}),"\n",(0,s.jsxs)(n.li,{children:["ROS 2 Documentation Team. (2023). ",(0,s.jsx)(n.em,{children:"rclpy User Guide"}),". Retrieved from ",(0,s.jsx)(n.a,{href:"https://docs.ros.org/en/humble/p/rclpy/",children:"https://docs.ros.org/en/humble/p/rclpy/"})]}),"\n",(0,s.jsxs)(n.li,{children:["Coltin, B., & D'Andrea, R. (2014). Python programming with ROS. ",(0,s.jsx)(n.em,{children:"Proceedings of the Workshop on Python for Education in Computer Science"}),", 23-30."]}),"\n",(0,s.jsx)(n.li,{children:"Source 007: Research on Python-based robotics development best practices"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);