"use strict";(globalThis.webpackChunkhomanoid_robotics_book=globalThis.webpackChunkhomanoid_robotics_book||[]).push([[1273],{8406:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-4/chapter-12","title":"Chapter 12: Cognitive Task Planning","description":"Learning Outcomes","source":"@site/docs/module-4/chapter-12.md","sourceDirName":"module-4","slug":"/module-4/chapter-12","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-4/chapter-12","draft":false,"unlisted":false,"editUrl":"https://github.com/KashanKamboh/Physical-AI-Humanoid-Robotics-Book.git/edit/main/docs/module-4/chapter-12.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 11: Voice-to-Action Agents","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-4/chapter-11"},"next":{"title":"Chapter 13: Capstone Execution","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-4/chapter-13"}}');var a=r(4848),s=r(8453);const i={sidebar_position:3},o="Chapter 12: Cognitive Task Planning",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites Checklist",id:"prerequisites-checklist",level:2},{value:"Required Software Installed",id:"required-software-installed",level:3},{value:"Required Module Completion",id:"required-module-completion",level:3},{value:"Files Needed",id:"files-needed",level:3},{value:"Core Concept Explanation",id:"core-concept-explanation",level:2},{value:"Cognitive Task Planning Architecture",id:"cognitive-task-planning-architecture",level:3},{value:"Behavior Trees for Task Execution",id:"behavior-trees-for-task-execution",level:3},{value:"Planning Paradigms",id:"planning-paradigms",level:3},{value:"Task Planning Integration",id:"task-planning-integration",level:3},{value:"Diagram or Pipeline",id:"diagram-or-pipeline",level:2},{value:"Runnable Code Example A",id:"runnable-code-example-a",level:2},{value:"Runnable Code Example B",id:"runnable-code-example-b",level:2},{value:"&quot;Try Yourself&quot; Mini Task",id:"try-yourself-mini-task",level:2},{value:"Verification Procedure",id:"verification-procedure",level:2},{value:"What appears in terminal?",id:"what-appears-in-terminal",level:3},{value:"What changes in simulation?",id:"what-changes-in-simulation",level:3},{value:"Checklist for Completion",id:"checklist-for-completion",level:2},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chapter-12-cognitive-task-planning",children:"Chapter 12: Cognitive Task Planning"})}),"\n",(0,a.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,a.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Implement hierarchical task planning systems for complex robotic behaviors"}),"\n",(0,a.jsx)(n.li,{children:"Create behavior trees for managing complex robot actions"}),"\n",(0,a.jsx)(n.li,{children:"Develop task decomposition algorithms for multi-step operations"}),"\n",(0,a.jsx)(n.li,{children:"Integrate perception and navigation into task execution"}),"\n",(0,a.jsx)(n.li,{children:"Build failure recovery mechanisms for robust task execution"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites-checklist",children:"Prerequisites Checklist"}),"\n",(0,a.jsx)(n.h3,{id:"required-software-installed",children:"Required Software Installed"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","ROS 2 Humble Hawksbill (or newer)"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","BehaviorTree.CPP library"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","PDDL planners (or alternative planning frameworks)"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Completed Module 1-3 content"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Completed Chapter 11 content"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"required-module-completion",children:"Required Module Completion"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understanding of ROS 2 action servers and clients"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Basic knowledge of planning algorithms"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Familiarity with behavior trees and state machines"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Experience with perception and navigation systems"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"files-needed",children:"Files Needed"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Access to planning domain definition files"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Sample task scenarios for testing"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"core-concept-explanation",children:"Core Concept Explanation"}),"\n",(0,a.jsx)(n.h3,{id:"cognitive-task-planning-architecture",children:"Cognitive Task Planning Architecture"}),"\n",(0,a.jsx)(n.p,{children:"Cognitive task planning bridges high-level goals with low-level robot actions through several layers:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Goal Specification"}),": Natural language or symbolic goal definition"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Task Decomposition"}),": Breaking complex goals into subtasks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Action Sequencing"}),": Ordering actions to achieve subtasks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resource Allocation"}),": Managing robot capabilities and constraints"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Execution Monitoring"}),": Tracking progress and handling failures"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Replanning"}),": Adjusting plans when conditions change"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"behavior-trees-for-task-execution",children:"Behavior Trees for Task Execution"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Behavior Trees"})," provide a structured approach to complex task execution:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Composites"}),": Control flow nodes (sequence, selector, parallel)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Decorators"}),": Modify child node behavior (inverter, repeater, timeout)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Actions"}),": Leaf nodes that execute specific robot behaviors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Conditions"}),": Check environmental states and preconditions"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Advantages of Behavior Trees"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Visual representation of task logic"}),"\n",(0,a.jsx)(n.li,{children:"Modular and reusable components"}),"\n",(0,a.jsx)(n.li,{children:"Easy to debug and modify"}),"\n",(0,a.jsx)(n.li,{children:"Support for concurrent execution"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"planning-paradigms",children:"Planning Paradigms"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Hierarchical Task Networks (HTN)"}),": Decompose high-level tasks into primitive actions:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Domain-specific knowledge for efficient planning"}),"\n",(0,a.jsx)(n.li,{children:"Operator-based decomposition"}),"\n",(0,a.jsx)(n.li,{children:"Support for task ordering constraints"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"PDDL-based Planning"}),": Use formal domain definitions for automated planning:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Symbolic state representation"}),"\n",(0,a.jsx)(n.li,{children:"Automated plan generation"}),"\n",(0,a.jsx)(n.li,{children:"Support for complex logical constraints"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Reactive Planning"}),": Combine planning with real-time reactivity:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Precomputed plans with runtime adjustments"}),"\n",(0,a.jsx)(n.li,{children:"Integration with perception and navigation"}),"\n",(0,a.jsx)(n.li,{children:"Failure detection and recovery"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"task-planning-integration",children:"Task Planning Integration"}),"\n",(0,a.jsx)(n.p,{children:"The planning system integrates with other robotic components:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Perception Interface"}),": Update world state based on sensor data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Navigation Interface"}),": Execute movement tasks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manipulation Interface"}),": Execute grasping and manipulation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Communication Interface"}),": Report status and request clarification"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"diagram-or-pipeline",children:"Diagram or Pipeline"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"graph TD\r\n    A[Cognitive Task Planning] --\x3e B[Goal Specification]\r\n    A --\x3e C[Task Decomposition]\r\n    A --\x3e D[Action Sequencing]\r\n    A --\x3e E[Resource Allocation]\r\n    A --\x3e F[Execution Monitoring]\r\n    A --\x3e G[Replanning]\r\n\r\n    B --\x3e B1[Natural Language Input]\r\n    B --\x3e B2[Symbolic Goals]\r\n    B --\x3e B3[Constraint Specification]\r\n\r\n    C --\x3e C1[Hierarchical Decomposition]\r\n    C --\x3e C2[Subtask Generation]\r\n    C --\x3e C3[Dependency Analysis]\r\n\r\n    D --\x3e D1[Action Ordering]\r\n    D --\x3e D2[Temporal Constraints]\r\n    D --\x3e D3[Precondition Checking]\r\n\r\n    E --\x3e E1[Capability Assessment]\r\n    E --\x3e E2[Resource Scheduling]\r\n    E --\x3e E3[Conflict Resolution]\r\n\r\n    F --\x3e F1[Progress Tracking]\r\n    F --\x3e F2[Failure Detection]\r\n    F --\x3e F3[Status Reporting]\r\n\r\n    G --\x3e G1[Plan Adaptation]\r\n    G --\x3e G2[Constraint Updates]\r\n    G --\x3e G3[Alternative Planning]\r\n\r\n    B1 --\x3e C\r\n    C1 --\x3e D\r\n    D1 --\x3e E\r\n    E1 --\x3e F\r\n    F1 --\x3e G\n"})}),"\n",(0,a.jsx)(n.h2,{id:"runnable-code-example-a",children:"Runnable Code Example A"}),"\n",(0,a.jsx)(n.p,{children:"Let's create a behavior tree-based task execution system:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# behavior_tree_planner.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.action import ActionClient\r\nfrom rclpy.qos import QoSProfile\r\nfrom std_msgs.msg import String, Bool\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom control_msgs.action import FollowJointTrajectory\r\nfrom sensor_msgs.msg import JointState\r\nimport time\r\nimport threading\r\nfrom enum import Enum\r\nfrom typing import Dict, List, Optional, Any\r\nfrom dataclasses import dataclass\r\n\r\n\r\nclass NodeStatus(Enum):\r\n    """Status of a behavior tree node"""\r\n    SUCCESS = "success"\r\n    FAILURE = "failure"\r\n    RUNNING = "running"\r\n\r\n\r\n@dataclass\r\nclass TaskGoal:\r\n    """Data class for task goals"""\r\n    type: str  # navigation, manipulation, perception, etc.\r\n    target: str\r\n    parameters: Dict[str, Any]\r\n    priority: int = 1\r\n\r\n\r\nclass BTNode:\r\n    """Base class for behavior tree nodes"""\r\n\r\n    def __init__(self, name: str):\r\n        self.name = name\r\n        self.status = NodeStatus.RUNNING\r\n\r\n    def tick(self) -> NodeStatus:\r\n        """Execute one cycle of the node"""\r\n        raise NotImplementedError\r\n\r\n\r\nclass ActionNode(BTNode):\r\n    """Leaf node that performs a specific action"""\r\n\r\n    def __init__(self, name: str, action_func):\r\n        super().__init__(name)\r\n        self.action_func = action_func\r\n\r\n    def tick(self) -> NodeStatus:\r\n        return self.action_func()\r\n\r\n\r\nclass SequenceNode(BTNode):\r\n    """Composite node that executes children in sequence"""\r\n\r\n    def __init__(self, name: str, children: List[BTNode]):\r\n        super().__init__(name)\r\n        self.children = children\r\n        self.current_child_idx = 0\r\n\r\n    def tick(self) -> NodeStatus:\r\n        while self.current_child_idx < len(self.children):\r\n            child_status = self.children[self.current_child_idx].tick()\r\n\r\n            if child_status == NodeStatus.FAILURE:\r\n                # Reset for next time\r\n                self.current_child_idx = 0\r\n                return NodeStatus.FAILURE\r\n            elif child_status == NodeStatus.RUNNING:\r\n                return NodeStatus.RUNNING\r\n            else:  # SUCCESS\r\n                self.current_child_idx += 1\r\n\r\n        # All children succeeded\r\n        self.current_child_idx = 0\r\n        return NodeStatus.SUCCESS\r\n\r\n\r\nclass SelectorNode(BTNode):\r\n    """Composite node that tries children until one succeeds"""\r\n\r\n    def __init__(self, name: str, children: List[BTNode]):\r\n        super().__init__(name)\r\n        self.children = children\r\n        self.current_child_idx = 0\r\n\r\n    def tick(self) -> NodeStatus:\r\n        while self.current_child_idx < len(self.children):\r\n            child_status = self.children[self.current_child_idx].tick()\r\n\r\n            if child_status == NodeStatus.SUCCESS:\r\n                # Reset for next time\r\n                self.current_child_idx = 0\r\n                return NodeStatus.SUCCESS\r\n            elif child_status == NodeStatus.RUNNING:\r\n                return NodeStatus.RUNNING\r\n            else:  # FAILURE\r\n                self.current_child_idx += 1\r\n\r\n        # All children failed\r\n        self.current_child_idx = 0\r\n        return NodeStatus.FAILURE\r\n\r\n\r\nclass DecoratorNode(BTNode):\r\n    """Base class for decorator nodes"""\r\n\r\n    def __init__(self, name: str, child: BTNode):\r\n        super().__init__(name)\r\n        self.child = child\r\n\r\n\r\nclass InverterNode(DecoratorNode):\r\n    """Decorator that inverts the result of its child"""\r\n\r\n    def tick(self) -> NodeStatus:\r\n        child_status = self.child.tick()\r\n\r\n        if child_status == NodeStatus.SUCCESS:\r\n            return NodeStatus.FAILURE\r\n        elif child_status == NodeStatus.FAILURE:\r\n            return NodeStatus.SUCCESS\r\n        else:\r\n            return child_status\r\n\r\n\r\nclass TimeoutNode(DecoratorNode):\r\n    """Decorator that times out its child after a duration"""\r\n\r\n    def __init__(self, name: str, child: BTNode, timeout: float):\r\n        super().__init__(name, child)\r\n        self.timeout = timeout\r\n        self.start_time = None\r\n\r\n    def tick(self) -> NodeStatus:\r\n        if self.start_time is None:\r\n            self.start_time = time.time()\r\n\r\n        if time.time() - self.start_time > self.timeout:\r\n            self.start_time = None\r\n            return NodeStatus.FAILURE\r\n\r\n        child_status = self.child.tick()\r\n\r\n        if child_status != NodeStatus.RUNNING:\r\n            self.start_time = None\r\n\r\n        return child_status\r\n\r\n\r\nclass BehaviorTreePlanner(Node):\r\n    """\r\n    A behavior tree-based task planning and execution system.\r\n    This demonstrates cognitive task planning for complex robotic behaviors.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'behavior_tree_planner\')\r\n\r\n        # Action clients\r\n        self.nav_action_client = ActionClient(\r\n            self,\r\n            NavigateToPose,\r\n            \'navigate_to_pose\'\r\n        )\r\n\r\n        self.manipulation_action_client = ActionClient(\r\n            self,\r\n            FollowJointTrajectory,\r\n            \'manipulation_controller/follow_joint_trajectory\'\r\n        )\r\n\r\n        # Publishers\r\n        self.status_pub = self.create_publisher(String, \'/task_planner/status\', 10)\r\n        self.task_pub = self.create_publisher(String, \'/task_planner/tasks\', 10)\r\n\r\n        # Subscribers\r\n        self.task_sub = self.create_subscription(\r\n            String,\r\n            \'/task_planner/goals\',\r\n            self.task_callback,\r\n            10\r\n        )\r\n\r\n        # Internal state\r\n        self.current_tree = None\r\n        self.task_queue = []\r\n        self.is_executing = False\r\n        self.execution_thread = None\r\n        self.world_state = {}  # Current state of the world\r\n\r\n        # Timer for periodic execution\r\n        self.execution_timer = self.create_timer(0.1, self.execute_tick)\r\n\r\n        self.get_logger().info(\'Behavior Tree Planner initialized\')\r\n\r\n    def task_callback(self, msg):\r\n        """Process incoming task goals"""\r\n        try:\r\n            import json\r\n            task_data = json.loads(msg.data)\r\n\r\n            task_goal = TaskGoal(\r\n                type=task_data[\'type\'],\r\n                target=task_data[\'target\'],\r\n                parameters=task_data.get(\'parameters\', {}),\r\n                priority=task_data.get(\'priority\', 1)\r\n            )\r\n\r\n            self.task_queue.append(task_goal)\r\n            self.get_logger().info(f\'Added task to queue: {task_goal.type} - {task_goal.target}\')\r\n\r\n            # Create behavior tree for this task\r\n            self.current_tree = self.create_behavior_tree(task_goal)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing task: {e}\')\r\n\r\n    def create_behavior_tree(self, task_goal: TaskGoal) -> BTNode:\r\n        """Create a behavior tree for the given task"""\r\n        if task_goal.type == \'navigation\':\r\n            return self.create_navigation_tree(task_goal)\r\n        elif task_goal.type == \'manipulation\':\r\n            return self.create_manipulation_tree(task_goal)\r\n        elif task_goal.type == \'complex_task\':\r\n            return self.create_complex_task_tree(task_goal)\r\n        else:\r\n            self.get_logger().warning(f\'Unknown task type: {task_goal.type}\')\r\n            return self.create_default_tree(task_goal)\r\n\r\n    def create_navigation_tree(self, task_goal: TaskGoal) -> BTNode:\r\n        """Create behavior tree for navigation tasks"""\r\n        # Get target coordinates\r\n        target_coords = self.get_location_coordinates(task_goal.target)\r\n\r\n        if not target_coords:\r\n            self.get_logger().error(f\'Unknown navigation target: {task_goal.target}\')\r\n            return self.create_default_tree(task_goal)\r\n\r\n        # Create navigation sequence\r\n        navigate_action = ActionNode(\r\n            "navigate_to_location",\r\n            lambda: self.execute_navigation(target_coords)\r\n        )\r\n\r\n        # Add preconditions and postconditions\r\n        check_clear_path = ActionNode(\r\n            "check_clear_path",\r\n            lambda: self.check_clear_path(target_coords)\r\n        )\r\n\r\n        # Sequence: check path -> navigate\r\n        navigation_sequence = SequenceNode(\r\n            "navigation_sequence",\r\n            [check_clear_path, navigate_action]\r\n        )\r\n\r\n        return navigation_sequence\r\n\r\n    def create_manipulation_tree(self, task_goal: TaskGoal) -> BTNode:\r\n        """Create behavior tree for manipulation tasks"""\r\n        # Create manipulation sequence\r\n        approach_object = ActionNode(\r\n            "approach_object",\r\n            lambda: self.execute_approach_object(task_goal.target)\r\n        )\r\n\r\n        grasp_object = ActionNode(\r\n            "grasp_object",\r\n            lambda: self.execute_grasp_object(task_goal.target)\r\n        )\r\n\r\n        lift_object = ActionNode(\r\n            "lift_object",\r\n            lambda: self.execute_lift_object(task_goal.target)\r\n        )\r\n\r\n        # Sequence: approach -> grasp -> lift\r\n        manipulation_sequence = SequenceNode(\r\n            "manipulation_sequence",\r\n            [approach_object, grasp_object, lift_object]\r\n        )\r\n\r\n        return manipulation_sequence\r\n\r\n    def create_complex_task_tree(self, task_goal: TaskGoal) -> BTNode:\r\n        """Create behavior tree for complex multi-step tasks"""\r\n        # Example: "Go to kitchen and bring me a cup"\r\n        # This would involve navigation, object detection, and manipulation\r\n\r\n        # Navigation to kitchen\r\n        navigate_to_kitchen = ActionNode(\r\n            "navigate_to_kitchen",\r\n            lambda: self.execute_navigation(self.get_location_coordinates(\'kitchen\'))\r\n        )\r\n\r\n        # Find cup\r\n        find_cup = ActionNode(\r\n            "find_cup",\r\n            lambda: self.execute_find_object(\'cup\')\r\n        )\r\n\r\n        # Grasp cup\r\n        grasp_cup = ActionNode(\r\n            "grasp_cup",\r\n            lambda: self.execute_grasp_object(\'cup\')\r\n        )\r\n\r\n        # Return to user\r\n        return_to_user = ActionNode(\r\n            "return_to_user",\r\n            lambda: self.execute_navigation(self.get_location_coordinates(\'user\'))\r\n        )\r\n\r\n        # Complex sequence: navigate -> find -> grasp -> return\r\n        complex_task_sequence = SequenceNode(\r\n            "complex_task_sequence",\r\n            [navigate_to_kitchen, find_cup, grasp_cup, return_to_user]\r\n        )\r\n\r\n        return complex_task_sequence\r\n\r\n    def create_default_tree(self, task_goal: TaskGoal) -> BTNode:\r\n        """Create default behavior tree for unknown tasks"""\r\n        error_action = ActionNode(\r\n            "report_error",\r\n            lambda: self.report_task_error(task_goal)\r\n        )\r\n\r\n        return error_action\r\n\r\n    def execute_tick(self):\r\n        """Execute one tick of the behavior tree"""\r\n        if self.current_tree and not self.is_executing:\r\n            self.is_executing = True\r\n\r\n            try:\r\n                status = self.current_tree.tick()\r\n\r\n                # Publish status\r\n                status_msg = String()\r\n                status_msg.data = f"Tree status: {status.value}"\r\n                self.status_pub.publish(status_msg)\r\n\r\n                if status != NodeStatus.RUNNING:\r\n                    self.get_logger().info(f\'Task completed with status: {status.value}\')\r\n                    self.current_tree = None\r\n                    self.is_executing = False\r\n\r\n                    # Process next task in queue\r\n                    if self.task_queue:\r\n                        next_task = self.task_queue.pop(0)\r\n                        self.current_tree = self.create_behavior_tree(next_task)\r\n\r\n            except Exception as e:\r\n                self.get_logger().error(f\'Error executing behavior tree: {e}\')\r\n                self.is_executing = False\r\n                self.current_tree = None\r\n\r\n    def execute_navigation(self, coordinates: tuple) -> NodeStatus:\r\n        """Execute navigation to coordinates"""\r\n        try:\r\n            # Wait for action server\r\n            if not self.nav_action_client.wait_for_server(timeout_sec=1.0):\r\n                self.get_logger().error(\'Navigation action server not available\')\r\n                return NodeStatus.FAILURE\r\n\r\n            # Create navigation goal\r\n            goal_msg = NavigateToPose.Goal()\r\n            goal_msg.pose.header.frame_id = \'map\'\r\n            goal_msg.pose.pose.position.x = coordinates[0]\r\n            goal_msg.pose.pose.position.y = coordinates[1]\r\n            goal_msg.pose.pose.position.z = coordinates[2]\r\n            goal_msg.pose.pose.orientation.w = 1.0\r\n\r\n            # Send goal asynchronously\r\n            goal_future = self.nav_action_client.send_goal_async(goal_msg)\r\n\r\n            # For this example, we\'ll return RUNNING to simulate ongoing navigation\r\n            # In a real implementation, you\'d track the goal status\r\n            return NodeStatus.RUNNING\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error in navigation: {e}\')\r\n            return NodeStatus.FAILURE\r\n\r\n    def check_clear_path(self, coordinates: tuple) -> NodeStatus:\r\n        """Check if path to coordinates is clear"""\r\n        # In real implementation, check costmap or perception data\r\n        # For now, assume path is clear\r\n        return NodeStatus.SUCCESS\r\n\r\n    def execute_approach_object(self, obj_name: str) -> NodeStatus:\r\n        """Execute approach to object"""\r\n        self.get_logger().info(f\'Approaching object: {obj_name}\')\r\n        # In real implementation, use perception and navigation\r\n        return NodeStatus.SUCCESS\r\n\r\n    def execute_grasp_object(self, obj_name: str) -> NodeStatus:\r\n        """Execute grasp of object"""\r\n        self.get_logger().info(f\'Grasping object: {obj_name}\')\r\n        # In real implementation, use manipulation system\r\n        return NodeStatus.SUCCESS\r\n\r\n    def execute_lift_object(self, obj_name: str) -> NodeStatus:\r\n        """Execute lift of object"""\r\n        self.get_logger().info(f\'Lifting object: {obj_name}\')\r\n        # In real implementation, use manipulation system\r\n        return NodeStatus.SUCCESS\r\n\r\n    def execute_find_object(self, obj_name: str) -> NodeStatus:\r\n        """Execute find object task"""\r\n        self.get_logger().info(f\'Finding object: {obj_name}\')\r\n        # In real implementation, use perception system\r\n        return NodeStatus.SUCCESS\r\n\r\n    def get_location_coordinates(self, location_name: str) -> Optional[tuple]:\r\n        """Get coordinates for location names"""\r\n        location_map = {\r\n            \'kitchen\': (3.0, 2.0, 0.0),\r\n            \'bedroom\': (-2.0, 1.0, 0.0),\r\n            \'living room\': (0.0, 0.0, 0.0),\r\n            \'office\': (1.0, -2.0, 0.0),\r\n            \'bathroom\': (-1.0, -1.0, 0.0),\r\n            \'user\': (0.0, 0.0, 0.0)  # Default user location\r\n        }\r\n\r\n        return location_map.get(location_name.lower())\r\n\r\n    def report_task_error(self, task_goal: TaskGoal) -> NodeStatus:\r\n        """Report error for unknown task"""\r\n        self.get_logger().error(f\'Cannot execute unknown task: {task_goal.type}\')\r\n        return NodeStatus.FAILURE\r\n\r\n\r\nclass AdvancedBehaviorTreePlanner(BehaviorTreePlanner):\r\n    """\r\n    Extended behavior tree planner with advanced features\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        # Add advanced features\r\n        self.failure_recovery_enabled = True\r\n        self.plan_monitoring_enabled = True\r\n        self.context_awareness_enabled = True\r\n\r\n        self.get_logger().info(\'Advanced Behavior Tree Planner initialized\')\r\n\r\n    def create_behavior_tree(self, task_goal: TaskGoal) -> BTNode:\r\n        """Create behavior tree with failure recovery"""\r\n        basic_tree = super().create_behavior_tree(task_goal)\r\n\r\n        # Add failure recovery wrapper\r\n        if self.failure_recovery_enabled:\r\n            recovery_tree = self.add_failure_recovery(basic_tree, task_goal)\r\n            return recovery_tree\r\n\r\n        return basic_tree\r\n\r\n    def add_failure_recovery(self, original_tree: BTNode, task_goal: TaskGoal) -> BTNode:\r\n        """Add failure recovery capabilities to a tree"""\r\n        # Create recovery sequence\r\n        recovery_action = ActionNode(\r\n            "execute_recovery",\r\n            lambda: self.execute_recovery(task_goal)\r\n        )\r\n\r\n        # Create selector: try original -> if fails, try recovery\r\n        recovery_selector = SelectorNode(\r\n            "recovery_selector",\r\n            [original_tree, recovery_action]\r\n        )\r\n\r\n        return recovery_selector\r\n\r\n    def execute_recovery(self, task_goal: TaskGoal) -> NodeStatus:\r\n        """Execute recovery behavior for failed tasks"""\r\n        self.get_logger().info(f\'Executing recovery for task: {task_goal.type}\')\r\n\r\n        # Different recovery strategies based on task type\r\n        if task_goal.type == \'navigation\':\r\n            return self.recover_navigation(task_goal)\r\n        elif task_goal.type == \'manipulation\':\r\n            return self.recover_manipulation(task_goal)\r\n        else:\r\n            return self.recover_general(task_goal)\r\n\r\n    def recover_navigation(self, task_goal: TaskGoal) -> NodeStatus:\r\n        """Recovery for navigation failures"""\r\n        self.get_logger().info(\'Trying alternative navigation approach\')\r\n        # In real implementation, try different path, ask for help, etc.\r\n        return NodeStatus.FAILURE  # For now, indicate recovery failed\r\n\r\n    def recover_manipulation(self, task_goal: TaskGoal) -> NodeStatus:\r\n        """Recovery for manipulation failures"""\r\n        self.get_logger().info(\'Trying alternative manipulation approach\')\r\n        # In real implementation, try different grasp, reposition, etc.\r\n        return NodeStatus.FAILURE  # For now, indicate recovery failed\r\n\r\n    def recover_general(self, task_goal: TaskGoal) -> NodeStatus:\r\n        """General recovery for other task types"""\r\n        self.get_logger().info(\'Executing general recovery\')\r\n        return NodeStatus.FAILURE  # For now, indicate recovery failed\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    # Create behavior tree planner\r\n    planner = AdvancedBehaviorTreePlanner()\r\n\r\n    try:\r\n        planner.get_logger().info(\'Behavior Tree Planner running...\')\r\n        rclpy.spin(planner)\r\n    except KeyboardInterrupt:\r\n        planner.get_logger().info(\'Shutting down Behavior Tree Planner\')\r\n    finally:\r\n        planner.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"To run this behavior tree planner:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Save it as ",(0,a.jsx)(n.code,{children:"behavior_tree_planner.py"})]}),"\n",(0,a.jsx)(n.li,{children:"Install required dependencies if needed"}),"\n",(0,a.jsxs)(n.li,{children:["Run: ",(0,a.jsx)(n.code,{children:"ros2 run <package_name> behavior_tree_planner"})]}),"\n",(0,a.jsxs)(n.li,{children:["Send tasks using: ",(0,a.jsx)(n.code,{children:'ros2 topic pub /task_planner/goals std_msgs/String "data: \'{\\"type\\": \\"navigation\\", \\"target\\": \\"kitchen\\", \\"parameters\\": {}}\'"'})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"runnable-code-example-b",children:"Runnable Code Example B"}),"\n",(0,a.jsx)(n.p,{children:"Now let's create a PDDL-based task planning system:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# pddl_task_planner.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.action import ActionClient\r\nfrom rclpy.qos import QoSProfile\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom control_msgs.action import FollowJointTrajectory\r\nimport time\r\nimport threading\r\nimport json\r\nimport re\r\nfrom typing import Dict, List, Optional, Tuple, Any\r\nfrom dataclasses import dataclass\r\nfrom enum import Enum\r\n\r\n\r\nclass TaskStatus(Enum):\r\n    \"\"\"Status of a task\"\"\"\r\n    PENDING = \"pending\"\r\n    PLANNING = \"planning\"\r\n    EXECUTING = \"executing\"\r\n    SUCCESS = \"success\"\r\n    FAILURE = \"failure\"\r\n    CANCELLED = \"cancelled\"\r\n\r\n\r\n@dataclass\r\nclass Task:\r\n    \"\"\"Data class for tasks\"\"\"\r\n    id: str\r\n    goal: str  # PDDL goal expression\r\n    objects: Dict[str, str]  # object_name: object_type\r\n    predicates: Dict[str, List[str]]  # predicate_name: [parameters]\r\n    status: TaskStatus = TaskStatus.PENDING\r\n    plan: List[Dict] = None  # List of actions in the plan\r\n    created_time: float = None\r\n\r\n\r\nclass PDDLPlanner:\r\n    \"\"\"\r\n    A simple PDDL-based planner for robotic tasks.\r\n    This simulates the functionality of a PDDL planner like Fast-Downward.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        self.domain_predicates = {\r\n            'at': ['location'],\r\n            'connected': ['location', 'location'],\r\n            'holding': ['object'],\r\n            'on': ['object', 'object'],\r\n            'clear': ['object'],\r\n            'arm-empty': []\r\n        }\r\n\r\n        self.domain_actions = {\r\n            'move': {\r\n                'parameters': ['?from', '?to'],\r\n                'preconditions': [\r\n                    'at(?from)',\r\n                    'connected(?from, ?to)'\r\n                ],\r\n                'effects': [\r\n                    'not at(?from)',\r\n                    'at(?to)'\r\n                ]\r\n            },\r\n            'pick-up': {\r\n                'parameters': ['?obj', '?loc'],\r\n                'preconditions': [\r\n                    'at(?loc)',\r\n                    'at(?obj, ?loc)',\r\n                    'arm-empty'\r\n                ],\r\n                'effects': [\r\n                    'not arm-empty',\r\n                    'holding(?obj)',\r\n                    'not at(?obj, ?loc)'\r\n                ]\r\n            },\r\n            'put-down': {\r\n                'parameters': ['?obj', '?loc'],\r\n                'preconditions': [\r\n                    'at(?loc)',\r\n                    'holding(?obj)'\r\n                ],\r\n                'effects': [\r\n                    'arm-empty',\r\n                    'at(?obj, ?loc)',\r\n                    'not holding(?obj)'\r\n                ]\r\n            }\r\n        }\r\n\r\n    def plan(self, goal: str, initial_state: Dict[str, List[str]]) -> Optional[List[Dict]]:\r\n        \"\"\"\r\n        Plan a sequence of actions to achieve the goal.\r\n        This is a simplified planner for demonstration purposes.\r\n        \"\"\"\r\n        # In a real implementation, this would interface with a PDDL planner like Fast-Downward\r\n\r\n        # Parse the goal to understand what needs to be achieved\r\n        goal_predicates = self.parse_goal(goal)\r\n\r\n        # For demonstration, create a simple plan based on common goals\r\n        plan = self.create_simple_plan(goal_predicates, initial_state)\r\n\r\n        return plan\r\n\r\n    def parse_goal(self, goal_str: str) -> List[str]:\r\n        \"\"\"Parse goal string into predicates\"\"\"\r\n        # Simple parsing for demonstration\r\n        # In real implementation, use proper PDDL parser\r\n        predicates = []\r\n\r\n        # Look for common patterns in goal expressions\r\n        at_pattern = r'at\\(([^)]+)\\)'\r\n        holding_pattern = r'holding\\(([^)]+)\\)'\r\n\r\n        at_matches = re.findall(at_pattern, goal_str)\r\n        holding_matches = re.findall(holding_pattern, goal_str)\r\n\r\n        for match in at_matches:\r\n            predicates.append(f'at({match})')\r\n\r\n        for match in holding_matches:\r\n            predicates.append(f'holding({match})')\r\n\r\n        return predicates\r\n\r\n    def create_simple_plan(self, goal_predicates: List[str], initial_state: Dict[str, List[str]]) -> List[Dict]:\r\n        \"\"\"Create a simple plan based on goal predicates\"\"\"\r\n        plan = []\r\n\r\n        for predicate in goal_predicates:\r\n            if predicate.startswith('at('):\r\n                # Extract target location\r\n                target = predicate[3:-1]  # Remove 'at(' and ')'\r\n\r\n                # Check current location\r\n                current_locations = initial_state.get('at', [])\r\n                if current_locations and current_locations[0] != target:\r\n                    # Add move action\r\n                    plan.append({\r\n                        'action': 'move',\r\n                        'parameters': [current_locations[0], target]\r\n                    })\r\n\r\n            elif predicate.startswith('holding('):\r\n                # Extract target object\r\n                target_obj = predicate[8:-1]  # Remove 'holding(' and ')'\r\n\r\n                # Check if already holding\r\n                holding_objects = initial_state.get('holding', [])\r\n                if not holding_objects or target_obj not in holding_objects:\r\n                    # Assume object is at current location for simplicity\r\n                    current_locations = initial_state.get('at', [])\r\n                    if current_locations:\r\n                        # Add pick-up action\r\n                        plan.append({\r\n                            'action': 'pick-up',\r\n                            'parameters': [target_obj, current_locations[0]]\r\n                        })\r\n\r\n        return plan\r\n\r\n\r\nclass PDDLTaskPlanner(Node):\r\n    \"\"\"\r\n    A PDDL-based task planning and execution system.\r\n    This demonstrates cognitive task planning using formal methods.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('pddl_task_planner')\r\n\r\n        # Action clients\r\n        self.nav_action_client = ActionClient(\r\n            self,\r\n            NavigateToPose,\r\n            'navigate_to_pose'\r\n        )\r\n\r\n        self.manipulation_action_client = ActionClient(\r\n            self,\r\n            FollowJointTrajectory,\r\n            'manipulation_controller/follow_joint_trajectory'\r\n        )\r\n\r\n        # Publishers\r\n        self.status_pub = self.create_publisher(String, '/pddl_planner/status', 10)\r\n        self.plan_pub = self.create_publisher(String, '/pddl_planner/plan', 10)\r\n        self.execution_pub = self.create_publisher(String, '/pddl_planner/execution', 10)\r\n\r\n        # Subscribers\r\n        self.task_sub = self.create_subscription(\r\n            String,\r\n            '/pddl_planner/tasks',\r\n            self.task_callback,\r\n            10\r\n        )\r\n\r\n        # Internal state\r\n        self.planner = PDDLPlanner()\r\n        self.task_queue = []\r\n        self.current_task = None\r\n        self.current_plan = []\r\n        self.plan_index = 0\r\n        self.is_executing = False\r\n        self.execution_thread = None\r\n\r\n        # World state (simplified)\r\n        self.world_state = {\r\n            'at': ['robot', 'home'],  # robot is at home location\r\n            'holding': [],  # robot is not holding anything\r\n            'objects_at': {  # objects and their locations\r\n                'cup': 'kitchen',\r\n                'book': 'table',\r\n                'ball': 'shelf'\r\n            }\r\n        }\r\n\r\n        # Timer for execution\r\n        self.execution_timer = self.create_timer(0.1, self.execute_plan_step)\r\n\r\n        self.get_logger().info('PDDL Task Planner initialized')\r\n\r\n    def task_callback(self, msg):\r\n        \"\"\"Process incoming task requests\"\"\"\r\n        try:\r\n            task_data = json.loads(msg.data)\r\n\r\n            # Create task object\r\n            task = Task(\r\n                id=f\"task_{int(time.time())}\",\r\n                goal=task_data['goal'],\r\n                objects=task_data.get('objects', {}),\r\n                predicates=task_data.get('predicates', {}),\r\n                created_time=time.time()\r\n            )\r\n\r\n            # Add to queue\r\n            self.task_queue.append(task)\r\n            self.get_logger().info(f'Added task to queue: {task.id} - {task.goal}')\r\n\r\n            # If no task is currently being processed, start planning\r\n            if self.current_task is None:\r\n                self.process_next_task()\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error processing task: {e}')\r\n\r\n    def process_next_task(self):\r\n        \"\"\"Process the next task in the queue\"\"\"\r\n        if self.task_queue:\r\n            self.current_task = self.task_queue.pop(0)\r\n            self.current_task.status = TaskStatus.PLANNING\r\n\r\n            # Publish status\r\n            self.publish_status(f\"Planning task {self.current_task.id}\")\r\n\r\n            # Generate plan\r\n            plan = self.generate_plan(self.current_task)\r\n\r\n            if plan:\r\n                self.current_task.plan = plan\r\n                self.current_task.status = TaskStatus.EXECUTING\r\n                self.current_plan = plan\r\n                self.plan_index = 0\r\n                self.is_executing = True\r\n\r\n                # Publish plan\r\n                plan_msg = String()\r\n                plan_msg.data = json.dumps({\r\n                    'task_id': self.current_task.id,\r\n                    'plan': self.current_plan,\r\n                    'status': 'generated'\r\n                })\r\n                self.plan_pub.publish(plan_msg)\r\n\r\n                self.get_logger().info(f'Generated plan with {len(plan)} steps')\r\n            else:\r\n                self.get_logger().error(f'Failed to generate plan for task {self.current_task.id}')\r\n                self.current_task.status = TaskStatus.FAILURE\r\n                self.current_task = None\r\n                self.current_plan = []\r\n                self.is_executing = False\r\n\r\n    def generate_plan(self, task: Task) -> Optional[List[Dict]]:\r\n        \"\"\"Generate a plan for the given task\"\"\"\r\n        try:\r\n            # Create initial state for planner\r\n            initial_state = self.create_initial_state()\r\n\r\n            # Use PDDL planner to generate plan\r\n            plan = self.planner.plan(task.goal, initial_state)\r\n\r\n            return plan\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error generating plan: {e}')\r\n            return None\r\n\r\n    def create_initial_state(self) -> Dict[str, List[str]]:\r\n        \"\"\"Create initial state for planning\"\"\"\r\n        state = {}\r\n\r\n        # Robot location\r\n        robot_locations = [loc for loc in self.world_state['at'] if loc != 'robot']\r\n        state['at'] = robot_locations\r\n\r\n        # Robot holding\r\n        state['holding'] = self.world_state['holding']\r\n\r\n        # Objects at locations\r\n        objects_at = {}\r\n        for obj, loc in self.world_state['objects_at'].items():\r\n            if loc not in objects_at:\r\n                objects_at[loc] = []\r\n            objects_at[loc].append(obj)\r\n\r\n        # Convert to at(object, location) format\r\n        state['at_obj'] = []\r\n        for obj, loc in self.world_state['objects_at'].items():\r\n            state['at_obj'].append(f\"{obj}_at_{loc}\")\r\n\r\n        return state\r\n\r\n    def execute_plan_step(self):\r\n        \"\"\"Execute one step of the current plan\"\"\"\r\n        if self.is_executing and self.current_plan and self.plan_index < len(self.current_plan):\r\n            action = self.current_plan[self.plan_index]\r\n\r\n            # Execute the action\r\n            success = self.execute_action(action)\r\n\r\n            if success:\r\n                # Update world state based on action effects\r\n                self.update_world_state(action)\r\n\r\n                # Publish execution status\r\n                exec_msg = String()\r\n                exec_msg.data = json.dumps({\r\n                    'task_id': self.current_task.id if self.current_task else 'none',\r\n                    'action': action,\r\n                    'status': 'completed',\r\n                    'step': self.plan_index + 1,\r\n                    'total': len(self.current_plan)\r\n                })\r\n                self.execution_pub.publish(exec_msg)\r\n\r\n                self.get_logger().info(f'Completed action: {action[\"action\"]} {action[\"parameters\"]}')\r\n\r\n                # Move to next action\r\n                self.plan_index += 1\r\n\r\n                # Check if plan is complete\r\n                if self.plan_index >= len(self.current_plan):\r\n                    self.get_logger().info(f'Task completed successfully: {self.current_task.id}')\r\n                    self.current_task.status = TaskStatus.SUCCESS\r\n                    self.is_executing = False\r\n                    self.current_task = None\r\n                    self.current_plan = []\r\n                    self.plan_index = 0\r\n\r\n                    # Process next task if available\r\n                    if self.task_queue:\r\n                        self.process_next_task()\r\n            else:\r\n                self.get_logger().error(f'Action failed: {action}')\r\n                self.current_task.status = TaskStatus.FAILURE\r\n                self.is_executing = False\r\n                self.current_task = None\r\n                self.current_plan = []\r\n                self.plan_index = 0\r\n        elif not self.is_executing and self.task_queue:\r\n            # Start processing next task\r\n            self.process_next_task()\r\n\r\n    def execute_action(self, action: Dict) -> bool:\r\n        \"\"\"Execute a single action\"\"\"\r\n        action_name = action['action']\r\n        params = action['parameters']\r\n\r\n        if action_name == 'move':\r\n            from_loc, to_loc = params\r\n            return self.execute_move(from_loc, to_loc)\r\n        elif action_name == 'pick-up':\r\n            obj, loc = params\r\n            return self.execute_pick_up(obj, loc)\r\n        elif action_name == 'put-down':\r\n            obj, loc = params\r\n            return self.execute_put_down(obj, loc)\r\n        else:\r\n            self.get_logger().error(f'Unknown action: {action_name}')\r\n            return False\r\n\r\n    def execute_move(self, from_loc: str, to_loc: str) -> bool:\r\n        \"\"\"Execute move action\"\"\"\r\n        self.get_logger().info(f'Moving from {from_loc} to {to_loc}')\r\n\r\n        # In real implementation, this would call navigation system\r\n        # For simulation, just update world state\r\n        if 'robot' in self.world_state['at']:\r\n            self.world_state['at'].remove('robot')\r\n        self.world_state['at'].append(to_loc)\r\n\r\n        return True\r\n\r\n    def execute_pick_up(self, obj: str, loc: str) -> bool:\r\n        \"\"\"Execute pick-up action\"\"\"\r\n        self.get_logger().info(f'Picking up {obj} at {loc}')\r\n\r\n        # Check if object is at the specified location\r\n        if self.world_state['objects_at'].get(obj) == loc:\r\n            # Update world state\r\n            self.world_state['holding'].append(obj)\r\n            del self.world_state['objects_at'][obj]\r\n\r\n            return True\r\n        else:\r\n            self.get_logger().error(f'Object {obj} not found at {loc}')\r\n            return False\r\n\r\n    def execute_put_down(self, obj: str, loc: str) -> bool:\r\n        \"\"\"Execute put-down action\"\"\"\r\n        self.get_logger().info(f'Putting down {obj} at {loc}')\r\n\r\n        # Check if robot is holding the object\r\n        if obj in self.world_state['holding']:\r\n            # Update world state\r\n            self.world_state['holding'].remove(obj)\r\n            self.world_state['objects_at'][obj] = loc\r\n\r\n            return True\r\n        else:\r\n            self.get_logger().error(f'Robot not holding {obj}')\r\n            return False\r\n\r\n    def update_world_state(self, action: Dict):\r\n        \"\"\"Update world state based on action effects\"\"\"\r\n        # In a real implementation, this would update the state based on action effects\r\n        # For this simulation, we update it during action execution\r\n        pass\r\n\r\n    def publish_status(self, status_msg: str):\r\n        \"\"\"Publish status message\"\"\"\r\n        msg = String()\r\n        msg.data = status_msg\r\n        self.status_pub.publish(msg)\r\n\r\n\r\nclass HierarchicalTaskNetworkPlanner(PDDLTaskPlanner):\r\n    \"\"\"\r\n    Extended planner using Hierarchical Task Networks (HTN)\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        # HTN-specific components\r\n        self.hierarchical_methods = {\r\n            'complex_navigation': [\r\n                {\r\n                    'task': 'navigate_to_kitchen',\r\n                    'subtasks': ['navigate_to_room', 'find_kitchen_table']\r\n                }\r\n            ],\r\n            'fetch_object': [\r\n                {\r\n                    'task': 'go_to_object_and_grasp',\r\n                    'subtasks': ['navigate_to_location', 'find_object', 'grasp_object']\r\n                }\r\n            ]\r\n        }\r\n\r\n        self.get_logger().info('HTN Task Planner initialized')\r\n\r\n    def generate_plan(self, task: Task) -> Optional[List[Dict]]:\r\n        \"\"\"Generate plan using HTN decomposition\"\"\"\r\n        # Try HTN decomposition first\r\n        htn_plan = self.decompose_with_htn(task)\r\n\r\n        if htn_plan:\r\n            return htn_plan\r\n\r\n        # Fall back to PDDL planning\r\n        return super().generate_plan(task)\r\n\r\n    def decompose_with_htn(self, task: Task) -> Optional[List[Dict]]:\r\n        \"\"\"Decompose task using HTN methods\"\"\"\r\n        # Check if this task can be decomposed using HTN\r\n        goal_lower = task.goal.lower()\r\n\r\n        if 'kitchen' in goal_lower:\r\n            return self.decompose_kitchen_task(task)\r\n        elif 'fetch' in goal_lower or 'bring' in goal_lower:\r\n            return self.decompose_fetch_task(task)\r\n\r\n        return None\r\n\r\n    def decompose_kitchen_task(self, task: Task) -> List[Dict]:\r\n        \"\"\"Decompose kitchen-related tasks\"\"\"\r\n        plan = []\r\n\r\n        # Navigate to kitchen\r\n        plan.append({\r\n            'action': 'move',\r\n            'parameters': ['home', 'kitchen']\r\n        })\r\n\r\n        # Additional actions based on specific goal\r\n        if 'cup' in task.goal.lower():\r\n            plan.append({\r\n                'action': 'pick-up',\r\n                'parameters': ['cup', 'kitchen']\r\n            })\r\n\r\n        return plan\r\n\r\n    def decompose_fetch_task(self, task: Task) -> List[Dict]:\r\n        \"\"\"Decompose fetch-related tasks\"\"\"\r\n        plan = []\r\n\r\n        # Extract object from goal\r\n        import re\r\n        obj_match = re.search(r'(cup|book|ball|object)', task.goal.lower())\r\n        obj = obj_match.group(1) if obj_match else 'object'\r\n\r\n        # Find object location\r\n        obj_location = self.find_object_location(obj)\r\n\r\n        if obj_location:\r\n            # Navigate to object\r\n            plan.append({\r\n                'action': 'move',\r\n                'parameters': ['home', obj_location]\r\n            })\r\n\r\n            # Pick up object\r\n            plan.append({\r\n                'action': 'pick-up',\r\n                'parameters': [obj, obj_location]\r\n            })\r\n\r\n            # Return home\r\n            plan.append({\r\n                'action': 'move',\r\n                'parameters': [obj_location, 'home']\r\n            })\r\n\r\n        return plan\r\n\r\n    def find_object_location(self, obj: str) -> Optional[str]:\r\n        \"\"\"Find location of an object\"\"\"\r\n        return self.world_state['objects_at'].get(obj)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    # Create PDDL task planner\r\n    planner = HierarchicalTaskNetworkPlanner()\r\n\r\n    try:\r\n        planner.get_logger().info('PDDL Task Planner running...')\r\n        rclpy.spin(planner)\r\n    except KeyboardInterrupt:\r\n        planner.get_logger().info('Shutting down PDDL Task Planner')\r\n    finally:\r\n        planner.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"To run this PDDL task planner:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Save it as ",(0,a.jsx)(n.code,{children:"pddl_task_planner.py"})]}),"\n",(0,a.jsxs)(n.li,{children:["Run: ",(0,a.jsx)(n.code,{children:"ros2 run <package_name> pddl_task_planner"})]}),"\n",(0,a.jsxs)(n.li,{children:["Send tasks using: ",(0,a.jsx)(n.code,{children:'ros2 topic pub /pddl_planner/tasks std_msgs/String "data: \'{\\"goal\\": \\"at(kitchen)\\"}\'"'})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"try-yourself-mini-task",children:'"Try Yourself" Mini Task'}),"\n",(0,a.jsx)(n.p,{children:"Create a complete cognitive task planning system that includes:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"A planner that can handle temporal constraints and resource conflicts"}),"\n",(0,a.jsx)(n.li,{children:"A replanning mechanism that adapts to changing conditions"}),"\n",(0,a.jsx)(n.li,{children:"Integration with perception to update world state during execution"}),"\n",(0,a.jsx)(n.li,{children:"A learning component that improves planning based on execution experience"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Hint:"})," Use a combination of PDDL for symbolic planning, behavior trees for execution control, and a world state manager that integrates with perception systems."]}),"\n",(0,a.jsx)(n.h2,{id:"verification-procedure",children:"Verification Procedure"}),"\n",(0,a.jsx)(n.p,{children:"To verify that your cognitive task planning system is working correctly:"}),"\n",(0,a.jsx)(n.h3,{id:"what-appears-in-terminal",children:"What appears in terminal?"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"When starting the planner: Initialization messages and domain loading"}),"\n",(0,a.jsx)(n.li,{children:"When generating plans: Plan steps and reasoning traces"}),"\n",(0,a.jsx)(n.li,{children:"When executing tasks: Action execution status and progress"}),"\n",(0,a.jsx)(n.li,{children:"When handling failures: Recovery attempts and replanning"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"what-changes-in-simulation",children:"What changes in simulation?"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Robot executes complex multi-step tasks in Gazebo/Isaac Sim"}),"\n",(0,a.jsx)(n.li,{children:"Task execution can be monitored and visualized in RViz2"}),"\n",(0,a.jsx)(n.li,{children:"World state updates based on perception and action outcomes"}),"\n",(0,a.jsx)(n.li,{children:"System adapts to changes and recovers from failures"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"checklist-for-completion",children:"Checklist for Completion"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Behavior tree-based task execution system implemented"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","PDDL-based planning system with action execution"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Integration with ROS 2 action servers for navigation/manipulation"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Failure recovery and replanning mechanisms"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Complete cognitive planning system with learning (Try Yourself task)"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Temporal and resource constraint handling implemented"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"This chapter covered cognitive task planning systems that convert high-level goals into executable robotic actions. You learned about behavior trees for structured task execution and PDDL-based planning for automated plan generation. The examples demonstrated implementing both reactive and deliberative planning approaches that can handle complex multi-step tasks with failure recovery and adaptation capabilities."}),"\n",(0,a.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Ghallab, M., Nau, D., & Traverso, P. (2016). ",(0,a.jsx)(n.em,{children:"Automated Planning and Acting"}),". Cambridge University Press."]}),"\n",(0,a.jsxs)(n.li,{children:["BehaviorTree.CPP Team. (2023). ",(0,a.jsx)(n.em,{children:"BehaviorTree.CPP Documentation"}),". Retrieved from ",(0,a.jsx)(n.a,{href:"https://www.behaviortree.dev/",children:"https://www.behaviortree.dev/"})]}),"\n",(0,a.jsxs)(n.li,{children:["Kaelbling, L. P., & Lozano-P\xe9rez, T. (2017). Integrated task and motion planning in belief space. ",(0,a.jsx)(n.em,{children:"International Journal of Robotics Research"}),", 32(9-10), 1041-1057."]}),"\n",(0,a.jsxs)(n.li,{children:["Cambon, S., Alami, R., & Gravot, F. (2009). A hierarchy of temporal convex polytopes for motion planning. ",(0,a.jsx)(n.em,{children:"International Journal of Robotics Research"}),", 28(5), 640-657."]}),"\n",(0,a.jsxs)(n.li,{children:["Karpas, E., & Domshlak, C. (2012). Cost-optimal planning with landmarks. ",(0,a.jsx)(n.em,{children:"Artificial Intelligence"}),", 193, 46-83."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);