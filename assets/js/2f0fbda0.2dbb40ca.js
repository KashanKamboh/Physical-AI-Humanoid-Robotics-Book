"use strict";(globalThis.webpackChunkhomanoid_robotics_book=globalThis.webpackChunkhomanoid_robotics_book||[]).push([[7411],{1235:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module-3/chapter-9","title":"Chapter 9: Autonomous Navigation","description":"Learning Outcomes","source":"@site/docs/module-3/chapter-9.md","sourceDirName":"module-3","slug":"/module-3/chapter-9","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3/chapter-9","draft":false,"unlisted":false,"editUrl":"https://github.com/KashanKamboh/Physical-AI-Humanoid-Robotics-Book.git/edit/main/docs/module-3/chapter-9.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 8: Isaac Simulation Pipeline","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3/chapter-8"},"next":{"title":"Chapter 10: Perception Pipeline","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3/chapter-10"}}');var t=r(4848),o=r(8453);const s={sidebar_position:3},i="Chapter 9: Autonomous Navigation",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites Checklist",id:"prerequisites-checklist",level:2},{value:"Required Software Installed",id:"required-software-installed",level:3},{value:"Required Module Completion",id:"required-module-completion",level:3},{value:"Files Needed",id:"files-needed",level:3},{value:"Core Concept Explanation",id:"core-concept-explanation",level:2},{value:"Navigation2 (Nav2) Architecture",id:"navigation2-nav2-architecture",level:3},{value:"Key Navigation Components",id:"key-navigation-components",level:3},{value:"Navigation Pipeline Flow",id:"navigation-pipeline-flow",level:3},{value:"Diagram or Pipeline",id:"diagram-or-pipeline",level:2},{value:"Runnable Code Example A",id:"runnable-code-example-a",level:2},{value:"Runnable Code Example B",id:"runnable-code-example-b",level:2},{value:"&quot;Try Yourself&quot; Mini Task",id:"try-yourself-mini-task",level:2},{value:"Verification Procedure",id:"verification-procedure",level:2},{value:"What appears in terminal?",id:"what-appears-in-terminal",level:3},{value:"What changes in simulation?",id:"what-changes-in-simulation",level:3},{value:"Checklist for Completion",id:"checklist-for-completion",level:2},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-9-autonomous-navigation",children:"Chapter 9: Autonomous Navigation"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Configure and tune Navigation2 (Nav2) for mobile robots"}),"\n",(0,t.jsx)(n.li,{children:"Implement global and local path planning algorithms"}),"\n",(0,t.jsx)(n.li,{children:"Set up costmap layers for obstacle avoidance"}),"\n",(0,t.jsx)(n.li,{children:"Create behavior trees for navigation recovery"}),"\n",(0,t.jsx)(n.li,{children:"Integrate navigation with perception systems"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites-checklist",children:"Prerequisites Checklist"}),"\n",(0,t.jsx)(n.h3,{id:"required-software-installed",children:"Required Software Installed"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","ROS 2 Humble Hawksbill (or newer)"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Navigation2 (Nav2) packages"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Isaac ROS navigation extensions"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","RViz2 for visualization"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Completed Module 1 and 2 content"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"required-module-completion",children:"Required Module Completion"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understanding of ROS 2 communication patterns"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Basic knowledge of path planning algorithms"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Familiarity with TF transforms"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Completed Chapter 8 content"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"files-needed",children:"Files Needed"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Completed robot model with proper transforms"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Access to Nav2 documentation and tutorials"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"core-concept-explanation",children:"Core Concept Explanation"}),"\n",(0,t.jsx)(n.h3,{id:"navigation2-nav2-architecture",children:"Navigation2 (Nav2) Architecture"}),"\n",(0,t.jsx)(n.p,{children:"Navigation2 is the navigation stack for ROS 2 that provides path planning, obstacle avoidance, and motion control capabilities. It's built on a behavior tree architecture that allows for complex navigation behaviors and recovery actions."}),"\n",(0,t.jsx)(n.h3,{id:"key-navigation-components",children:"Key Navigation Components"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Global Planner"}),": Computes optimal paths from start to goal:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A* algorithm for grid-based planning"}),"\n",(0,t.jsx)(n.li,{children:"Dijkstra's algorithm for weighted graphs"}),"\n",(0,t.jsx)(n.li,{children:"RRT (Rapidly-exploring Random Tree) for complex environments"}),"\n",(0,t.jsx)(n.li,{children:"Custom plugins for specialized planning"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Local Planner"}),": Executes short-term motion while avoiding obstacles:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"DWA (Dynamic Window Approach)"}),"\n",(0,t.jsx)(n.li,{children:"TEB (Timed Elastic Band)"}),"\n",(0,t.jsx)(n.li,{children:"MPC (Model Predictive Control)"}),"\n",(0,t.jsx)(n.li,{children:"Trajectory rollout algorithms"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Costmap Management"}),": Maintains environment representation:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Static map layer (known obstacles)"}),"\n",(0,t.jsx)(n.li,{children:"Obstacle layer (sensor-based obstacles)"}),"\n",(0,t.jsx)(n.li,{children:"Inflation layer (safety margins)"}),"\n",(0,t.jsx)(n.li,{children:"Voxel layer (3D obstacle representation)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Behavior Trees"}),": Organize navigation logic and recovery:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Sequential execution of navigation tasks"}),"\n",(0,t.jsx)(n.li,{children:"Conditional branches for different scenarios"}),"\n",(0,t.jsx)(n.li,{children:"Recovery behaviors for failed actions"}),"\n",(0,t.jsx)(n.li,{children:"Parallel execution of monitoring tasks"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"navigation-pipeline-flow",children:"Navigation Pipeline Flow"}),"\n",(0,t.jsx)(n.p,{children:"The navigation system follows this pipeline:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal Reception"}),": Accept navigation goal from client"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Global Planning"}),": Compute path to goal"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Local Planning"}),": Execute path with obstacle avoidance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Motion Control"}),": Send velocity commands to robot"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitoring"}),": Track progress and detect failures"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recovery"}),": Execute recovery behaviors if needed"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"diagram-or-pipeline",children:"Diagram or Pipeline"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"graph TD\r\n    A[Navigation2 System] --\x3e B[Goal Management]\r\n    A --\x3e C[Global Planner]\r\n    A --\x3e D[Local Planner]\r\n    A --\x3e E[Costmap Manager]\r\n    A --\x3e F[Behavior Tree]\r\n    A --\x3e G[Recovery System]\r\n\r\n    B --\x3e B1[Goal Reception]\r\n    B --\x3e B2[Goal Validation]\r\n    B --\x3e B3[Goal Transformation]\r\n\r\n    C --\x3e C1[Path Planning]\r\n    C --\x3e C2[Path Smoothing]\r\n    C --\x3e C3[Path Validation]\r\n\r\n    D --\x3e D1[Velocity Commands]\r\n    D --\x3e D2[Obstacle Avoidance]\r\n    D --\x3e D3[Path Following]\r\n\r\n    E --\x3e E1[Static Map]\r\n    E --\x3e E2[Obstacle Layer]\r\n    E --\x3e E3[Inflation Layer]\r\n\r\n    F --\x3e F1[Navigation Task]\r\n    F --\x3e F2[Monitoring Task]\r\n    F --\x3e F3[Recovery Task]\r\n\r\n    G --\x3e G1[Clear Costmap]\r\n    G --\x3e G2[Rotate Recovery]\r\n    G --\x3e G3[Back Up Recovery]\r\n\r\n    B1 --\x3e C\r\n    C1 --\x3e D\r\n    E1 --\x3e D\r\n    F1 --\x3e D\r\n    D1 --\x3e G\r\n    G1 --\x3e B\n"})}),"\n",(0,t.jsx)(n.h2,{id:"runnable-code-example-a",children:"Runnable Code Example A"}),"\n",(0,t.jsx)(n.p,{children:"Let's create a navigation server that implements Nav2 with custom configurations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# nav2_server.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\r\nfrom rclpy.callback_groups import ReentrantCallbackGroup\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nfrom rclpy.qos import QoSProfile\r\n\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom nav_msgs.msg import Path\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom tf2_ros import TransformException\r\nfrom tf2_ros.buffer import Buffer\r\nfrom tf2_ros.transform_listener import TransformListener\r\n\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom nav2_msgs.srv import LoadMap, ClearEntireCostmap\r\n\r\nimport math\r\nimport time\r\nfrom typing import Optional\r\n\r\n\r\nclass Nav2Server(Node):\r\n    """\r\n    A custom navigation server implementing Nav2 functionality.\r\n    This demonstrates the core components of autonomous navigation.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'nav2_server\')\r\n\r\n        # Initialize TF buffer and listener\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n\r\n        # Publishers\r\n        self.path_pub = self.create_publisher(Path, \'/plan\', 10)\r\n        self.cmd_vel_pub = self.create_publisher(PoseStamped, \'/goal_pose\', 10)\r\n\r\n        # Subscribers\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan,\r\n            \'/scan\',\r\n            self.scan_callback,\r\n            10\r\n        )\r\n\r\n        # Action server for navigation\r\n        self.nav_action_server = ActionServer(\r\n            self,\r\n            NavigateToPose,\r\n            \'navigate_to_pose\',\r\n            execute_callback=self.execute_navigate_to_pose,\r\n            callback_group=ReentrantCallbackGroup(),\r\n            goal_callback=self.goal_callback,\r\n            cancel_callback=self.cancel_callback\r\n        )\r\n\r\n        # Service clients for costmap management\r\n        self.clear_costmap_client = self.create_client(\r\n            ClearEntireCostmap,\r\n            \'global_costmap/clear_entirely_global_costmap\'\r\n        )\r\n        self.clear_local_costmap_client = self.create_client(\r\n            ClearEntireCostmap,\r\n            \'local_costmap/clear_entirely_local_costmap\'\r\n        )\r\n\r\n        # Internal state\r\n        self.current_pose = None\r\n        self.current_goal = None\r\n        self.is_navigating = False\r\n        self.obstacle_detected = False\r\n\r\n        self.get_logger().info(\'Nav2 Server initialized\')\r\n\r\n    def scan_callback(self, msg):\r\n        """Process laser scan data for obstacle detection"""\r\n        # Check for obstacles in front of robot (simplified)\r\n        front_scan = msg.ranges[140:220]  # Front 80-degree field\r\n        front_scan = [d for d in front_scan if d > 0 and d < 10.0]  # Filter valid readings\r\n\r\n        if front_scan:\r\n            min_distance = min(front_scan)\r\n            self.obstacle_detected = min_distance < 0.5  # 0.5m threshold\r\n\r\n    def goal_callback(self, goal_request):\r\n        """Handle incoming navigation goals"""\r\n        self.get_logger().info(f\'Received navigation goal: {goal_request.pose.pose}\')\r\n\r\n        # Validate goal\r\n        if self.validate_goal(goal_request.pose):\r\n            return GoalResponse.ACCEPT\r\n        else:\r\n            return GoalResponse.REJECT\r\n\r\n    def cancel_callback(self, goal_handle):\r\n        """Handle goal cancellation"""\r\n        self.get_logger().info(\'Navigation goal cancelled\')\r\n        return CancelResponse.ACCEPT\r\n\r\n    def validate_goal(self, goal_pose):\r\n        """Validate navigation goal"""\r\n        # In real implementation, check if goal is reachable\r\n        # For now, accept all goals\r\n        return True\r\n\r\n    async def execute_navigate_to_pose(self, goal_handle):\r\n        """Execute navigation to pose goal"""\r\n        self.get_logger().info(\'Executing navigation goal\')\r\n\r\n        goal_pose = goal_handle.request.pose\r\n        feedback_msg = NavigateToPose.Feedback()\r\n        result = NavigateToPose.Result()\r\n\r\n        # Store current goal\r\n        self.current_goal = goal_pose\r\n        self.is_navigating = True\r\n\r\n        try:\r\n            # Get current robot pose\r\n            current_pose = await self.get_robot_pose()\r\n            if not current_pose:\r\n                self.get_logger().error(\'Could not get robot pose\')\r\n                goal_handle.abort()\r\n                result.error_code = result.ERROR\r\n                return result\r\n\r\n            # Plan path to goal (simplified - in real implementation, use proper planner)\r\n            path = self.plan_path(current_pose, goal_pose)\r\n            if not path:\r\n                self.get_logger().error(\'Could not plan path to goal\')\r\n                goal_handle.abort()\r\n                result.error_code = result.ERROR\r\n                return result\r\n\r\n            # Publish path for visualization\r\n            path_msg = self.create_path_message(path)\r\n            self.path_pub.publish(path_msg)\r\n\r\n            # Execute navigation\r\n            success = await self.follow_path(path, goal_pose, feedback_msg, goal_handle)\r\n\r\n            if success:\r\n                self.get_logger().info(\'Navigation completed successfully\')\r\n                goal_handle.succeed()\r\n                result.error_code = result.SUCCESS\r\n            else:\r\n                self.get_logger().error(\'Navigation failed\')\r\n                goal_handle.abort()\r\n                result.error_code = result.ERROR\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Navigation execution error: {e}\')\r\n            goal_handle.abort()\r\n            result.error_code = result.ERROR\r\n\r\n        finally:\r\n            self.is_navigating = False\r\n            self.current_goal = None\r\n\r\n        return result\r\n\r\n    async def get_robot_pose(self):\r\n        """Get current robot pose from TF"""\r\n        try:\r\n            transform = self.tf_buffer.lookup_transform(\r\n                \'map\', \'base_link\', rclpy.time.Time()\r\n            )\r\n            pose = PoseStamped()\r\n            pose.header.frame_id = \'map\'\r\n            pose.pose.position.x = transform.transform.translation.x\r\n            pose.pose.position.y = transform.transform.translation.y\r\n            pose.pose.position.z = transform.transform.translation.z\r\n            pose.pose.orientation = transform.transform.rotation\r\n            return pose\r\n        except TransformException as ex:\r\n            self.get_logger().error(f\'Could not get robot pose: {ex}\')\r\n            return None\r\n\r\n    def plan_path(self, start_pose, goal_pose):\r\n        """Plan path from start to goal (simplified implementation)"""\r\n        # This is a simplified path planner - in real implementation,\r\n        # use proper path planning algorithms like A*, Dijkstra, etc.\r\n\r\n        path = []\r\n\r\n        # Calculate path points (linear interpolation for demonstration)\r\n        start_x = start_pose.pose.position.x\r\n        start_y = start_pose.pose.position.y\r\n        goal_x = goal_pose.pose.position.x\r\n        goal_y = goal_pose.pose.position.y\r\n\r\n        # Simple linear path (in real implementation, use proper path planner)\r\n        steps = 50  # Number of path points\r\n        for i in range(steps + 1):\r\n            t = i / steps\r\n            x = start_x + t * (goal_x - start_x)\r\n            y = start_y + t * (goal_y - start_y)\r\n\r\n            point = Point()\r\n            point.x = x\r\n            point.y = y\r\n            point.z = 0.0\r\n            path.append(point)\r\n\r\n        return path\r\n\r\n    def create_path_message(self, path_points):\r\n        """Create Path message from path points"""\r\n        path_msg = Path()\r\n        path_msg.header.frame_id = \'map\'\r\n        path_msg.header.stamp = self.get_clock().now().to_msg()\r\n\r\n        for point in path_points:\r\n            pose = PoseStamped()\r\n            pose.header.frame_id = \'map\'\r\n            pose.pose.position = point\r\n            pose.pose.orientation.w = 1.0  # Default orientation\r\n            path_msg.poses.append(pose)\r\n\r\n        return path_msg\r\n\r\n    async def follow_path(self, path, goal_pose, feedback_msg, goal_handle):\r\n        """Follow the planned path with obstacle avoidance"""\r\n        self.get_logger().info(\'Following path...\')\r\n\r\n        for i, point in enumerate(path):\r\n            if not self.is_navigating or goal_handle.is_cancel_requested:\r\n                if goal_handle.is_cancel_requested:\r\n                    goal_handle.canceled()\r\n                return False\r\n\r\n            # Move to next path point\r\n            success = await self.move_to_point(point)\r\n            if not success:\r\n                self.get_logger().warning(\'Failed to reach path point, attempting recovery\')\r\n                recovery_success = await self.execute_recovery_behaviors()\r\n                if not recovery_success:\r\n                    return False\r\n\r\n            # Update feedback\r\n            feedback_msg.current_pose = await self.get_robot_pose()\r\n            feedback_msg.distance_remaining = self.calculate_distance_to_goal(\r\n                feedback_msg.current_pose, goal_pose\r\n            )\r\n            goal_handle.publish_feedback(feedback_msg)\r\n\r\n            # Check for obstacles\r\n            if self.obstacle_detected:\r\n                self.get_logger().warning(\'Obstacle detected during navigation\')\r\n                # In real implementation, replan or execute obstacle avoidance\r\n                time.sleep(0.1)  # Simulate obstacle handling\r\n\r\n        # Check if we reached the goal\r\n        current_pose = await self.get_robot_pose()\r\n        if current_pose:\r\n            distance_to_goal = self.calculate_distance_to_goal(current_pose, goal_pose)\r\n            return distance_to_goal < 0.5  # 0.5m tolerance\r\n        return False\r\n\r\n    async def move_to_point(self, target_point):\r\n        """Move robot to target point (simplified controller)"""\r\n        # In real implementation, use proper local planner like DWA or TEB\r\n        # This is a simple proportional controller for demonstration\r\n\r\n        max_attempts = 100\r\n        tolerance = 0.1  # 10cm tolerance\r\n\r\n        for attempt in range(max_attempts):\r\n            current_pose = await self.get_robot_pose()\r\n            if not current_pose:\r\n                return False\r\n\r\n            # Calculate distance to target\r\n            dx = target_point.x - current_pose.pose.position.x\r\n            dy = target_point.y - current_pose.pose.position.y\r\n            distance = math.sqrt(dx*dx + dy*dy)\r\n\r\n            if distance < tolerance:\r\n                return True  # Reached target point\r\n\r\n            # Calculate required velocity (simplified)\r\n            linear_speed = min(0.2, distance)  # Max 0.2 m/s\r\n            angular_speed = math.atan2(dy, dx)  # Simple heading control\r\n\r\n            # Publish velocity command\r\n            cmd_msg = PoseStamped()\r\n            cmd_msg.header.frame_id = \'base_link\'\r\n            cmd_msg.pose.position.x = linear_speed\r\n            cmd_msg.pose.orientation.z = angular_speed\r\n            self.cmd_vel_pub.publish(cmd_msg)\r\n\r\n            time.sleep(0.1)  # 10Hz control loop\r\n\r\n        return False  # Failed to reach point\r\n\r\n    async def execute_recovery_behaviors(self):\r\n        """Execute recovery behaviors when navigation fails"""\r\n        self.get_logger().info(\'Executing recovery behaviors\')\r\n\r\n        # Clear costmaps\r\n        await self.clear_costmaps()\r\n\r\n        # Try rotating in place to clear obstacles\r\n        self.get_logger().info(\'Attempting rotation recovery\')\r\n        success = await self.rotate_recovery()\r\n        if success:\r\n            return True\r\n\r\n        # Try backing up\r\n        self.get_logger().info(\'Attempting backup recovery\')\r\n        success = await self.backup_recovery()\r\n        if success:\r\n            return True\r\n\r\n        return False\r\n\r\n    async def clear_costmaps(self):\r\n        """Clear global and local costmaps"""\r\n        try:\r\n            # Clear global costmap\r\n            while not self.clear_costmap_client.wait_for_service(timeout_sec=1.0):\r\n                self.get_logger().info(\'Waiting for global costmap clear service...\')\r\n\r\n            req = ClearEntireCostmap.Request()\r\n            future = self.clear_costmap_client.call_async(req)\r\n            await future\r\n\r\n            # Clear local costmap\r\n            while not self.clear_local_costmap_client.wait_for_service(timeout_sec=1.0):\r\n                self.get_logger().info(\'Waiting for local costmap clear service...\')\r\n\r\n            future = self.clear_local_costmap_client.call_async(req)\r\n            await future\r\n\r\n            self.get_logger().info(\'Costmaps cleared\')\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error clearing costmaps: {e}\')\r\n\r\n    async def rotate_recovery(self):\r\n        """Execute rotation recovery behavior"""\r\n        self.get_logger().info(\'Executing rotation recovery\')\r\n\r\n        # Publish rotation command\r\n        cmd_msg = PoseStamped()\r\n        cmd_msg.header.frame_id = \'base_link\'\r\n        cmd_msg.pose.orientation.z = 0.5  # Rotate at 0.5 rad/s\r\n\r\n        for i in range(20):  # Rotate for 2 seconds\r\n            self.cmd_vel_pub.publish(cmd_msg)\r\n            time.sleep(0.1)\r\n\r\n        return True\r\n\r\n    async def backup_recovery(self):\r\n        """Execute backup recovery behavior"""\r\n        self.get_logger().info(\'Executing backup recovery\')\r\n\r\n        # Publish backward command\r\n        cmd_msg = PoseStamped()\r\n        cmd_msg.header.frame_id = \'base_link\'\r\n        cmd_msg.pose.position.x = -0.1  # Move backward at 0.1 m/s\r\n\r\n        for i in range(10):  # Move back for 1 second\r\n            self.cmd_vel_pub.publish(cmd_msg)\r\n            time.sleep(0.1)\r\n\r\n        return True\r\n\r\n    def calculate_distance_to_goal(self, current_pose, goal_pose):\r\n        """Calculate distance between current pose and goal pose"""\r\n        if not current_pose:\r\n            return float(\'inf\')\r\n\r\n        dx = goal_pose.pose.position.x - current_pose.pose.position.x\r\n        dy = goal_pose.pose.position.y - current_pose.pose.position.y\r\n        return math.sqrt(dx*dx + dy*dy)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    nav2_server = Nav2Server()\r\n\r\n    # Use MultiThreadedExecutor to handle callbacks properly\r\n    executor = MultiThreadedExecutor(num_threads=4)\r\n    executor.add_node(nav2_server)\r\n\r\n    try:\r\n        nav2_server.get_logger().info(\'Nav2 Server starting...\')\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        nav2_server.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"To run this navigation server:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Save it as ",(0,t.jsx)(n.code,{children:"nav2_server.py"})]}),"\n",(0,t.jsx)(n.li,{children:"Make sure Nav2 packages are installed"}),"\n",(0,t.jsxs)(n.li,{children:["Launch with: ",(0,t.jsx)(n.code,{children:"ros2 run <package_name> nav2_server"})]}),"\n",(0,t.jsxs)(n.li,{children:["Send navigation goals using: ",(0,t.jsx)(n.code,{children:"ros2 action send_goal /navigate_to_pose nav2_msgs/action/NavigateToPose \"{pose: {header: {frame_id: 'map'}, pose: {position: {x: 1.0, y: 1.0, z: 0.0}, orientation: {w: 1.0}}}}\""})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"runnable-code-example-b",children:"Runnable Code Example B"}),"\n",(0,t.jsx)(n.p,{children:"Now let's create a navigation client that can send goals and monitor progress:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# nav2_client.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.action import ActionClient\r\nfrom rclpy.qos import QoSProfile\r\n\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom tf2_ros import TransformException\r\nfrom tf2_ros.buffer import Buffer\r\nfrom tf2_ros.transform_listener import TransformListener\r\n\r\nimport time\r\nimport random\r\n\r\n\r\nclass Nav2Client(Node):\r\n    """\r\n    A navigation client that sends goals to Nav2 and monitors progress.\r\n    This demonstrates how to interact with the navigation system.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'nav2_client\')\r\n\r\n        # Initialize TF buffer and listener\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n\r\n        # Action client for navigation\r\n        self.nav_action_client = ActionClient(\r\n            self,\r\n            NavigateToPose,\r\n            \'navigate_to_pose\'\r\n        )\r\n\r\n        # Publishers for visualization\r\n        self.goal_pub = self.create_publisher(PoseStamped, \'/goal_pose\', 10)\r\n\r\n        # Subscribers\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan,\r\n            \'/scan\',\r\n            self.scan_callback,\r\n            10\r\n        )\r\n\r\n        # Internal state\r\n        self.current_goal = None\r\n        self.navigation_active = False\r\n        self.obstacle_detected = False\r\n\r\n        # Timer for sending periodic goals\r\n        self.goal_timer = self.create_timer(10.0, self.send_periodic_goal)\r\n\r\n        self.get_logger().info(\'Nav2 Client initialized\')\r\n\r\n    def scan_callback(self, msg):\r\n        """Process laser scan data"""\r\n        # Check for obstacles in front of robot\r\n        front_scan = msg.ranges[140:220]  # Front 80-degree field\r\n        front_scan = [d for d in front_scan if d > 0 and d < 10.0]\r\n\r\n        if front_scan:\r\n            min_distance = min(front_scan)\r\n            self.obstacle_detected = min_distance < 0.5\r\n\r\n    def send_goal(self, x, y, theta=0.0):\r\n        """Send a navigation goal to the server"""\r\n        # Wait for action server\r\n        self.nav_action_client.wait_for_server()\r\n\r\n        # Create goal message\r\n        goal_msg = NavigateToPose.Goal()\r\n        goal_msg.pose.header.frame_id = \'map\'\r\n        goal_msg.pose.pose.position.x = x\r\n        goal_msg.pose.pose.position.y = y\r\n        goal_msg.pose.pose.position.z = 0.0\r\n\r\n        # Convert theta to quaternion (simplified)\r\n        import math\r\n        goal_msg.pose.pose.orientation.z = math.sin(theta / 2.0)\r\n        goal_msg.pose.pose.orientation.w = math.cos(theta / 2.0)\r\n\r\n        # Send goal\r\n        self.get_logger().info(f\'Sending navigation goal to ({x}, {y})\')\r\n        self.current_goal = goal_msg.pose\r\n        self.navigation_active = True\r\n\r\n        # Send goal asynchronously\r\n        self._send_goal_future = self.nav_action_client.send_goal_async(\r\n            goal_msg,\r\n            feedback_callback=self.feedback_callback\r\n        )\r\n\r\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\r\n\r\n    def goal_response_callback(self, future):\r\n        """Handle goal response"""\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info(\'Goal rejected\')\r\n            self.navigation_active = False\r\n            return\r\n\r\n        self.get_logger().info(\'Goal accepted\')\r\n        self._get_result_future = goal_handle.get_result_async()\r\n        self._get_result_future.add_done_callback(self.get_result_callback)\r\n\r\n    def get_result_callback(self, future):\r\n        """Handle navigation result"""\r\n        result = future.result().result\r\n        status = future.result().status\r\n\r\n        if status == 4:  # SUCCEEDED\r\n            self.get_logger().info(\'Navigation succeeded!\')\r\n        elif status == 5:  # CANCELED\r\n            self.get_logger().info(\'Navigation was canceled\')\r\n        else:\r\n            self.get_logger().info(f\'Navigation failed with status: {status}\')\r\n\r\n        self.navigation_active = False\r\n        self.current_goal = None\r\n\r\n    def feedback_callback(self, feedback_msg):\r\n        """Handle navigation feedback"""\r\n        feedback = feedback_msg.feedback\r\n        self.get_logger().debug(\r\n            f\'Navigation progress: {feedback.distance_remaining:.2f}m remaining\'\r\n        )\r\n\r\n    def send_periodic_goal(self):\r\n        """Send periodic navigation goals for demonstration"""\r\n        if not self.navigation_active:\r\n            # Generate random goal in a reasonable area\r\n            x = random.uniform(-5.0, 5.0)\r\n            y = random.uniform(-5.0, 5.0)\r\n\r\n            # Make sure goal is not too close to current position\r\n            current_pose = self.get_current_pose()\r\n            if current_pose:\r\n                dx = x - current_pose.pose.position.x\r\n                dy = y - current_pose.pose.position.y\r\n                distance = (dx*dx + dy*dy)**0.5\r\n\r\n                if distance > 1.0:  # Only send if far enough away\r\n                    self.send_goal(x, y)\r\n            else:\r\n                # If we can\'t get current pose, just send the random goal\r\n                self.send_goal(x, y)\r\n\r\n    def get_current_pose(self):\r\n        """Get current robot pose from TF"""\r\n        try:\r\n            transform = self.tf_buffer.lookup_transform(\r\n                \'map\', \'base_link\', rclpy.time.Time()\r\n            )\r\n            pose = PoseStamped()\r\n            pose.header.frame_id = \'map\'\r\n            pose.pose.position.x = transform.transform.translation.x\r\n            pose.pose.position.y = transform.transform.translation.y\r\n            pose.pose.position.z = transform.transform.translation.z\r\n            pose.pose.orientation = transform.transform.rotation\r\n            return pose\r\n        except TransformException:\r\n            return None\r\n\r\n    def send_waypoint_sequence(self):\r\n        """Send a sequence of waypoints for complex navigation"""\r\n        waypoints = [\r\n            (2.0, 2.0, 0.0),\r\n            (4.0, 1.0, 1.57),\r\n            (3.0, -2.0, 3.14),\r\n            (0.0, 0.0, 0.0)  # Return to start\r\n        ]\r\n\r\n        def send_next_waypoint(index=0):\r\n            if index < len(waypoints):\r\n                x, y, theta = waypoints[index]\r\n                self.get_logger().info(f\'Sending waypoint {index + 1}: ({x}, {y})\')\r\n\r\n                # Wait for previous navigation to complete before sending next\r\n                if not self.navigation_active:\r\n                    self.send_goal(x, y, theta)\r\n                    # Schedule next waypoint after a delay\r\n                    self.create_timer(5.0, lambda: send_next_waypoint(index + 1))\r\n                else:\r\n                    # If navigation is active, check again in 1 second\r\n                    self.create_timer(1.0, lambda: send_next_waypoint(index))\r\n\r\n        send_next_waypoint()\r\n\r\n    def cancel_current_goal(self):\r\n        """Cancel the current navigation goal"""\r\n        if self.navigation_active and self.current_goal:\r\n            # In real implementation, you would send a cancel request\r\n            self.get_logger().info(\'Cancelling current navigation goal\')\r\n            self.navigation_active = False\r\n            self.current_goal = None\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    nav2_client = Nav2Client()\r\n\r\n    # Send an initial goal\r\n    nav2_client.send_goal(3.0, 3.0)\r\n\r\n    try:\r\n        rclpy.spin(nav2_client)\r\n    except KeyboardInterrupt:\r\n        nav2_client.get_logger().info(\'Shutting down Nav2 Client\')\r\n    finally:\r\n        nav2_client.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"To run this navigation client:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Save it as ",(0,t.jsx)(n.code,{children:"nav2_client.py"})]}),"\n",(0,t.jsxs)(n.li,{children:["Run: ",(0,t.jsx)(n.code,{children:"ros2 run <package_name> nav2_client"})]}),"\n",(0,t.jsx)(n.li,{children:"The client will send periodic navigation goals to the server"}),"\n",(0,t.jsx)(n.li,{children:"Use RViz2 to visualize the navigation process"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"try-yourself-mini-task",children:'"Try Yourself" Mini Task'}),"\n",(0,t.jsx)(n.p,{children:"Create an autonomous navigation system that includes:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"A global costmap with static and dynamic obstacle layers"}),"\n",(0,t.jsx)(n.li,{children:"A local costmap for immediate obstacle avoidance"}),"\n",(0,t.jsx)(n.li,{children:"A behavior tree that includes multiple recovery behaviors"}),"\n",(0,t.jsx)(n.li,{children:"Integration with perception sensors to detect and avoid dynamic obstacles"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Hint:"})," Use Nav2's built-in costmap layers and behavior tree nodes, then extend them with custom recovery behaviors for your specific robot platform."]}),"\n",(0,t.jsx)(n.h2,{id:"verification-procedure",children:"Verification Procedure"}),"\n",(0,t.jsx)(n.p,{children:"To verify that your navigation system is working correctly:"}),"\n",(0,t.jsx)(n.h3,{id:"what-appears-in-terminal",children:"What appears in terminal?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When starting navigation server: Service and action server initialization"}),"\n",(0,t.jsx)(n.li,{children:"When sending goals: Goal acceptance and execution messages"}),"\n",(0,t.jsx)(n.li,{children:"When following paths: Progress feedback and distance updates"}),"\n",(0,t.jsx)(n.li,{children:"When executing recovery: Recovery behavior activation messages"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"what-changes-in-simulation",children:"What changes in simulation?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Robot moves along planned paths in Gazebo/Isaac Sim"}),"\n",(0,t.jsx)(n.li,{children:"Costmaps update with obstacle information in RViz2"}),"\n",(0,t.jsx)(n.li,{children:"Navigation goals are visualized with planned paths"}),"\n",(0,t.jsx)(n.li,{children:"Recovery behaviors execute when obstacles are detected"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"checklist-for-completion",children:"Checklist for Completion"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Navigation server with proper path planning implemented"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Navigation client with goal sending and monitoring"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Costmap layers configured for obstacle detection"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Recovery behaviors implemented and tested"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Behavior tree with multiple navigation strategies (Try Yourself task)"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Integration with perception sensors completed"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This chapter covered autonomous navigation using Navigation2 (Nav2), the standard navigation stack for ROS 2. You learned about the key components of navigation systems including global and local planners, costmap management, and behavior trees for recovery. The examples demonstrated implementing a navigation server and client that can plan paths, avoid obstacles, and execute recovery behaviors when needed."}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Navigation2 Team. (2023). ",(0,t.jsx)(n.em,{children:"Navigation2 User Guide"}),". Retrieved from ",(0,t.jsx)(n.a,{href:"https://navigation.ros.org/",children:"https://navigation.ros.org/"})]}),"\n",(0,t.jsxs)(n.li,{children:["Lu, C., et al. (2020). Navigation2: An End-to-End Navigation Framework for Mobile Robots. ",(0,t.jsx)(n.em,{children:"IEEE Robotics and Automation Letters"}),", 5(4), 5999-6006."]}),"\n",(0,t.jsxs)(n.li,{children:["Fox, D., Burgard, W., & Thrun, S. (1997). The dynamic window approach to collision avoidance. ",(0,t.jsx)(n.em,{children:"IEEE Robotics & Automation Magazine"}),", 4(1), 23-33."]}),"\n",(0,t.jsxs)(n.li,{children:["ROS 2 Navigation Working Group. (2023). ",(0,t.jsx)(n.em,{children:"Nav2 Behavior Trees Documentation"}),". Technical Report."]}),"\n",(0,t.jsxs)(n.li,{children:["ROS 2 Navigation Working Group. (2023). ",(0,t.jsx)(n.em,{children:"Costmap 2D Package Documentation"}),". Technical Report."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>i});var a=r(6540);const t={},o=a.createContext(t);function s(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);